-- Производитель
CREATE TABLE производитель
(
	id_производитель integer GENERATED BY DEFAULT AS IDENTITY, 
	название text NOT NULL UNIQUE, 
	страна text NOT NULL,
	PRIMARY KEY (id_производитель)
);

INSERT INTO производитель (название, страна) 
VALUES ('Intel', 'США'),  ('Xiaomi', 'Китай'), ('ASUS', 'Китай'), ('AMD', 'США'), ('Samsung', 'Южная Корея');

-- Категория
CREATE TABLE категория
(
	id_категория integer GENERATED BY DEFAULT AS IDENTITY, 
	название text NOT NULL UNIQUE,
	PRIMARY KEY (id_категория)
);

INSERT INTO категория (название) 
VALUES ('Смартфоны'),  ('Телевизоры'), ('Смартчасы'), ('Ноутбуки'), ('Процессоры'), ('Пылесосы');

-- Товар
CREATE TABLE товар
(
	id_товар integer GENERATED BY DEFAULT AS IDENTITY, 
	id_производитель integer NOT NULL,
	id_категория integer NOT NULL,
	наименование text NOT NULL, 
	стоимость real NOT NULL CHECK (стоимость > 0), 
	гарантийный_срок smallint NOT NULL CHECK (гарантийный_срок > 0),
	характеристики jsonb,
	PRIMARY KEY (id_товар),
	UNIQUE (id_производитель, наименование),
	CONSTRAINT производитель_exists FOREIGN KEY (id_производитель)
        REFERENCES производитель (id_производитель)
        ON UPDATE CASCADE
        ON DELETE CASCADE,
	CONSTRAINT категория_exists FOREIGN KEY (id_категория)
        REFERENCES категория (id_категория)
        ON UPDATE CASCADE
        ON DELETE CASCADE
);

INSERT INTO товар (id_производитель, id_категория, наименование, стоимость, гарантийный_срок, характеристики) VALUES 
(1, 5, 'i5-11400F', 17200, 36, '{"Количество ядер": 6, "Количество потоков": 12, "Архитектура": "Rocket Lake", "Встроенное видеоядро": false, "Базовая частота (МГц)": 2.6, "Частота в режиме Turbo": 4.4}'),
(4, 5, 'Ryzen 5800X', 37900, 36, '{"Количество ядер": 6, "Количество потоков": 12, "Архитектура": "Zen 3", "Встроенное видеоядро" : false, "Кеш L3" : 32 }'),
(4, 5, 'Ryzen 5600X', 23600, 36, '{"Количество ядер": 8, "Количество потоков": 16, "Архитектура": "Zen 3", "Встроенное видеоядро" : false, "Кеш L3" : 32 }'),
(2, 1, 'Redmi Note 8T', 12000, 12, '{"ОС": "Android 9.0 Pie", "Процессор": "Snapdragon 665", "Камера (Мп)": 48, "Количество ядер" : 8, "Разрешение экрана" : "2340x1080", "Технология изготовления экрана" : "IPS" }');

CREATE VIEW товар_v AS 
(SELECT id_товар, производитель.название AS "Производитель", категория.название AS "Категория", 
наименование AS "Наименование", стоимость AS "Стоимость", гарантийный_срок AS "Гарантийный срок", характеристики AS "Характеристики"
FROM товар 
INNER JOIN производитель ON товар.id_производитель = производитель.id_производитель 
INNER JOIN категория ON товар.id_категория = категория.id_категория);

-- Товар на складе
CREATE TABLE товар_на_складе
(
	id_товар_на_складе integer GENERATED BY DEFAULT AS IDENTITY, 
	id_товар integer NOT NULL,
	время_поступления timestamp NOT NULL,
	дата_изготовления date NOT NULL,
	количество smallint CHECK (количество >= 0),
	PRIMARY KEY (id_товар_на_складе),
	CONSTRAINT товар_exists FOREIGN KEY (id_товар)
        REFERENCES товар (id_товар)
        ON UPDATE CASCADE
        ON DELETE CASCADE
);

-- Представление
CREATE VIEW товар_на_складе_v AS 
SELECT id_товар_на_складе, (товар_v.Производитель || ' ' || товар_v.Наименование) AS "Товар", to_char(товар_на_складе.время_поступления, 'DD-MM-YYYY HH24:MI:SS') AS "Время поступления", товар_на_складе.дата_изготовления AS "Дата изготовления", товар_на_складе.количество AS "Количество" 
FROM товар_на_складе INNER JOIN товар_v ON (товар_на_складе.id_товар = товар_v.id_товар);

-- Функция добавления товара на склад
CREATE OR REPLACE FUNCTION add_product_to_warehouse
(IN id int, IN production_date date, IN count int) 
RETURNS void
AS $BODY$
BEGIN	
	IF count = 0
	THEN 
		RAISE 'Insert product with count 0' USING ERRCODE = 'check_violation';
	END IF;
	INSERT INTO товар_на_складе (id_товар, время_поступления, дата_изготовления, количество) 
		VALUES (id, now(), production_date, count);
END;
$BODY$
LANGUAGE plpgsql;

GRANT EXECUTE ON FUNCTION add_product_to_warehouse(int, date, int) TO operator;

SELECT add_product_to_warehouse(4, '2020-12-14', 10);

-- Пункт выдачи
CREATE TABLE пункт_выдачи
(
	id_пункт_выдачи integer GENERATED BY DEFAULT AS IDENTITY, 
	название text NOT NULL,
	адрес text NOT NULL,	
	площадь real NOT NULL CHECK (площадь > 0),
	доп_функции text[], -- оплата картой, наличными, возможность примерки
	PRIMARY KEY (id_пункт_выдачи)
);

INSERT INTO пункт_выдачи (название, адрес, площадь, доп_функции) 
VALUES ('ТЦ Ярмарка', 'г. Астрахань, Вокзальная площадь, д. 13', '40',
		ARRAY['Оплата наличными', 'Оплата картой', 'Примерка одежды']),
		('Пункт Ozon', 'г. Астрахань, ул. Яблочкова, д. 44', '50',
		ARRAY['Оплата наличными', 'Примерка обуви', 'Примерка одежды', 'Возврат товаров']);
		
-- Клиент
CREATE TABLE клиент
(
	id_клиент integer GENERATED BY DEFAULT AS IDENTITY, 
	фамилия text NOT NULL, 
	имя text, 
	отчество text, 
	телефон varchar(11) NOT NULL UNIQUE CHECK (LENGTH(телефон) = 11), 
	email text,
	PRIMARY KEY (id_клиент)
);

-- менеджер
CREATE TABLE менеджер
(
	id_менеджер integer GENERATED BY DEFAULT AS IDENTITY, 
	фамилия text NOT NULL, 
	имя text NOT NULL, 
	отчество text, 
	телефон varchar(11) NOT NULL UNIQUE CHECK (LENGTH(телефон) = 11), 
	email text NOT NULL,
	PRIMARY KEY (id_менеджер)
);

-- Статус
CREATE TABLE статус
(
	id_статус integer GENERATED BY DEFAULT AS IDENTITY, 
	название text NOT NULL UNIQUE, -- открыт, завершен, отменён
	PRIMARY KEY (id_статус)
);

INSERT INTO статус (название) 
VALUES ('Открыт'), ('Завершен'), ('Отменён');

-- Заказ
CREATE TABLE заказ
(
	id_заказ integer GENERATED BY DEFAULT AS IDENTITY, 
	id_клиент integer NOT NULL,
	id_статус integer NOT NULL,
	id_пункт_выдачи integer NOT NULL,
	id_менеджер integer,
	дата_оформления date NOT NULL,
	дата_выдачи date,
	общая_сумма real NOT NULL CHECK (общая_сумма > 0),
	PRIMARY KEY (id_заказ),
	CONSTRAINT клиент_exists FOREIGN KEY (id_клиент)
        REFERENCES клиент (id_клиент)
        ON UPDATE CASCADE
        ON DELETE CASCADE,
	CONSTRAINT статус_exists FOREIGN KEY (id_статус)
        REFERENCES статус (id_статус)
        ON UPDATE CASCADE
        ON DELETE CASCADE,
	CONSTRAINT пункт_выдачи_exists FOREIGN KEY (id_пункт_выдачи)
        REFERENCES пункт_выдачи (id_пункт_выдачи)
        ON UPDATE CASCADE
        ON DELETE CASCADE,
	CONSTRAINT менеджер_exists FOREIGN KEY (id_менеджер)
        REFERENCES менеджер (id_менеджер)
        ON UPDATE CASCADE
        ON DELETE CASCADE
);

-- Позиция в заказе
CREATE TABLE позиция_заказа
(
	id_заказ integer NOT NULL,
	id_товар_на_складе integer NOT NULL,
	количество smallint CHECK (количество > 0),
	PRIMARY KEY (id_заказ, id_товар_на_складе),
	CONSTRAINT заказ_exists FOREIGN KEY (id_заказ)
        REFERENCES заказ (id_заказ)
        ON UPDATE CASCADE
        ON DELETE CASCADE,
	CONSTRAINT товар_на_складе_exists FOREIGN KEY (id_товар_на_складе)
        REFERENCES товар_на_складе (id_товар_на_складе)
        ON UPDATE CASCADE
        ON DELETE CASCADE
);

-- Создание ролей
CREATE USER operator PASSWORD 'oper123';
GRANT SELECT ON категория, менеджер, производитель, пункт_выдачи, товар_на_складе, товар_на_складе_v, товар, товар_v TO operator;
GRANT INSERT, UPDATE, DELETE ON категория TO operator;
GRANT INSERT, UPDATE, DELETE ON производитель TO operator;
GRANT INSERT, UPDATE, DELETE ON пункт_выдачи TO operator;
GRANT INSERT, UPDATE, DELETE ON товар TO operator;
GRANT INSERT, DELETE ON товар_на_складе TO operator;

CREATE GROUP managers;
GRANT SELECT ON заказ TO managers;

CREATE USER buyer PASSWORD 'buyer';

-- Функция добавления нового менеджера
CREATE OR REPLACE FUNCTION add_manager
(IN surname text, IN name text, IN otchestvo text, IN tel text, IN email text, IN passw text) 
RETURNS void
SECURITY DEFINER
AS $BODY$
BEGIN	
	INSERT INTO менеджер (фамилия, имя, отчество, телефон, email) 
		VALUES (surname, name, otchestvo, tel, email);
		
	EXECUTE FORMAT('CREATE USER %I PASSWORD ''%I'' IN ROLE managers', email, passw);
END;
$BODY$
LANGUAGE plpgsql;

-- Функция редактирования менеджера
CREATE OR REPLACE FUNCTION update_manager
(IN id int, IN surname text, IN name text, IN otchestvo text, IN tel text, IN new_mail text, IN passw text) 
RETURNS void
SECURITY DEFINER
AS $BODY$
DECLARE
	old_mail text;
BEGIN	
	old_mail := (SELECT email FROM менеджер WHERE id_менеджер = id);
	IF (SELECT usename FROM pg_user WHERE old_mail != new_mail AND usename = new_mail) IS NOT NULL
	THEN 
		RAISE reserved_name;
	ELSE 
		UPDATE менеджер 
		SET фамилия = surname, 
		имя = name, 
		отчество = otchestvo, 
		телефон = tel, 
		email = new_mail
		WHERE id_менеджер = id;
		
		EXECUTE FORMAT('ALTER USER %I WITH PASSWORD ''%I''', old_mail, passw);
		
		IF (old_mail != new_mail)
		THEN
			EXECUTE FORMAT('ALTER USER %I RENAME TO %I', old_mail, new_mail);
		END IF;
	END IF;
END;
$BODY$
LANGUAGE plpgsql;

-- Функция удаления менеджера
CREATE OR REPLACE FUNCTION delete_manager
(IN id int) 
RETURNS void
SECURITY DEFINER
AS $BODY$
DECLARE
	login text;
BEGIN	
	login := (SELECT email FROM менеджер WHERE id_менеджер = id);
	DELETE FROM менеджер WHERE id_менеджер = id;
	EXECUTE FORMAT('DROP USER %I', login);
END;
$BODY$
LANGUAGE plpgsql;  

-- Разрешаем добавлять, изменять и удалять менеджеров оператору
GRANT EXECUTE ON FUNCTION add_manager(text, text, text, text, text, text) TO operator;
GRANT EXECUTE ON FUNCTION update_manager(int, text, text, text, text, text, text) TO operator;
GRANT EXECUTE ON FUNCTION delete_manager(int) TO operator;
-- Добавляем несколько менеджеров
SELECT add_manager('Иванов', 'Иван', 'Иванович', '79999999979', 'test@mail.ru', 'test1');
SELECT add_manager('Петров', 'Петр', 'Петрович', '79089195979', 'petr1@yandex.ru', 'petya');
SELECT add_manager('Алексеев', 'Алексей', 'Алексеевич', '79889225979', 'alexey88@mail.ru', 'leha1');

-- Функция - кто я?
CREATE OR REPLACE FUNCTION whoami() 
RETURNS text
SECURITY DEFINER
AS $BODY$
DECLARE
	group_role text;
	this_user text;
BEGIN	
	this_user := (SELECT session_user);
	group_role := (SELECT rolname FROM pg_user
				JOIN pg_auth_members ON (pg_user.usesysid=pg_auth_members.member)
				JOIN pg_roles ON (pg_roles.oid=pg_auth_members.roleid)
				WHERE pg_user.usename = this_user);
	IF group_role IS NOT NULL
	THEN
		RETURN group_role;
	ELSE 
		RETURN this_user;
	END IF;
END;
$BODY$
LANGUAGE plpgsql;

-- Разрешаем функцию для оператора, менеджеров и покупателя
GRANT EXECUTE ON FUNCTION whoami() TO operator, managers, buyer;