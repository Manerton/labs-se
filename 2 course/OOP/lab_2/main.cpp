#include <iostream>
#include <cassert>
#include "bitstring.h"

using namespace std;

int main()
{
    system("chcp 1251 > nul");
    cout << "Лабораторная работа №2. Вариант 7.\nАвтор: Катунин Сергей. ДИПРБ-21.\n" << endl;
    cout << "Условие: Создать класс BitString для работы с 128-битовыми строками."
            "Битовая строка должна быть представлена двумя полями типа unsigned long long. "
            "Должны быть реализованы все традиционные операции для работы с битами: and, or, xor, not. "
            "Реализовать сдвиг влево shiftLeft и сдвиг вправо shiftRight на заданное количество битов. "
            "Реализовать операцию вычисления количества единичных битов, операции сравнения по количеству единичных битов. "
            "Реализовать операцию проверки включения." << endl;
    try // ищем исключения, которые выбрасываются в блоке try и отправляем их для обработки в блок(и) catch
    {
        cout << "\n-2. Создание битовой строки BS00, инициализация одним целым числом и последующий вывод строки BS00." << endl;
        BitString BS00 = 0b1101001;
        cout << BS00;
        cout << "\n-1. Создание битовой строки BS01, инициализация двумя целыми числом и последующий вывод строки BS01." << endl;
        BitString BS01(0b1111111111111111111111111111111111111111111111111111111111111111,0b0000000000000000000000000000000000000000000000000000000000000111);
        cout << BS01;
        cout << "\n0. Создание битовой строки BS0 без инициализации (конструктор по умолчанию, т.е поля равны 0 и 0 соответственно) и последующий вывод строки BS0." << endl;
        BitString BS0;
        cout << BS0;
        cout << "\n1. Создание строки BS1, инициализация строкой \"00100110\" и последующий вывод строки BS1." << endl;
        BitString BS1("00100110");
        cout << BS1;
        cout << "\nРазмер класса в байтах: "; // в режиме pragma pack (1) будет такой же размер, так как все поля класса одного типа uint64_t
        cout << sizeof(BS1) << endl;
        cout << "\n2. Создание строки BS2, инициализация строкой введенной с клавиатуры." << endl;
        BitString BS2;
        cin >> BS2;
        cout << BS2;
        cout << "\n3. Создание строки BS3, инициализация объектом BS2 и последующий вывод BS3." << endl;
        BitString BS3 = BS2;
        cout << "BS3: " << BS3;
        BitString testBS1 = 0b110101;
        BitString testBS2 = 0b001001;
        BitString testBS3 = 0b100110;
        BitString testBS4("11010111100011101011110001011010110001100010000000000000000000011010111100011101011110001011010110001100010000000000000000000011");
        assert((BS1 & testBS1) == 0b100100);
        assert((BS1 & testBS1).toString() == "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100100");
        assert((BS1 & testBS2).toString() == "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000");
        assert((BS1 & testBS3).toString() == "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100110");
        assert((BS1 & testBS4).toString() == "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010");

        assert((BS1 | testBS1).toString() == "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000110111");
        assert((BS1 | testBS2).toString() == "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000101111");
        assert((BS1 | testBS3).toString() == "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100110");
        assert((BS1 | testBS4).toString() == "11010111100011101011110001011010110001100010000000000000000000011010111100011101011110001011010110001100010000000000000000100111");

        assert((BS1 ^ testBS1).toString() == "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010011");
        assert((BS1 ^ testBS2).toString() == "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000101111");
        assert((BS1 ^ testBS3).toString() == "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000");
        assert((BS1 ^ testBS4).toString() == "11010111100011101011110001011010110001100010000000000000000000011010111100011101011110001011010110001100010000000000000000100101");

        assert((~testBS1).toString() == "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111001010");
        assert((~testBS2).toString() == "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110110");
        assert((~testBS3).toString() == "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111011001");
        assert((~testBS4).toString() == "00101000011100010100001110100101001110011101111111111111111111100101000011100010100001110100101001110011101111111111111111111100");

        assert((testBS1 << 3).toString() == "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000110101000");
        assert((testBS2 << 3).toString() == "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001001000");
        assert((testBS3 << 3).toString() == "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100110000");
        assert((testBS4 << 3).toString() == "10111100011101011110001011010110001100010000000000000000000011010111100011101011110001011010110001100010000000000000000000011000");

        assert((testBS1 >> 4).toString() == "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011");
        assert((testBS2 >> 4).toString() == "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000");
        assert((testBS3 >> 4).toString() == "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010");
        assert((testBS4 >> 4).toString() == "00001101011110001110101111000101101011000110001000000000000000000001101011110001110101111000101101011000110001000000000000000000");

        cout << "\n4. Количество единичных битов в BS1: " << (BS1.count_of_SingleBit());

        assert(BS1 < testBS1);
        assert(!(BS1 >= testBS1));
        assert(!(BS1 > testBS1));
        assert(BS1 <= testBS1);
        assert(!(BS1 == testBS1));
        assert(BS1 != testBS1);
        assert(!(is_included(BS1,testBS1)));
        assert(!(is_included(testBS1,BS1)));
        assert(testBS1.count_of_SingleBit() == 4);

        assert(!(BS1 < testBS2));
        assert(BS1 >= testBS2);
        assert(BS1 > testBS2);
        assert(!(BS1 <= testBS2));
        assert(!(BS1 == testBS2));
        assert(BS1 != testBS2);
        assert(!(is_included(BS1,testBS2)));
        assert(is_included(testBS2,BS1));
        assert(testBS2.count_of_SingleBit() == 2);

        assert(!(BS1 < testBS3));
        assert(BS1 >= testBS3);
        assert(!(BS1 > testBS3));
        assert(BS1 <= testBS3);
        assert(BS1 == testBS3);
        assert(!(BS1 != testBS3));
        assert(is_included(BS1,testBS3));
        assert(is_included(testBS3,BS1));
        assert(testBS3.count_of_SingleBit() == 3);

        assert(BS1 < testBS4);
        assert(!(BS1 >= testBS4));
        assert(!(BS1 > testBS4));
        assert(BS1 <= testBS4);
        assert(!(BS1 == testBS4));
        assert(BS1 != testBS4);
        assert(!(is_included(BS1,testBS4)));
        assert(!(is_included(testBS4,BS1)));
        assert(testBS4.count_of_SingleBit() == 50);

    }
    catch (BitString::not_binary_exception)
    {
        cerr << "Ошибка: введенное число не является двоичным." << endl;
    }
    catch (BitString::overflow_exception)
    {
        cerr << "Ошибка: битовая строка не может быть больше чем 128 бита." << endl;
    }
    return 0;
}

